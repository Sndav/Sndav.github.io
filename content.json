{"posts":[{"title":"Hello World","text":"2023 年 7 月 30 日 13:41:49，我重新搭建了 Github 博客。 这是我的第 n 篇博客，但是是在新 blog 当中的第一篇。在崭新的博客中，我将会记录我的学习历程，我的生活，我的感悟，我的成长。除了记录我的学习和生活之外，我希望能通过博客锻炼我的文笔，提高我的表达能力，让自己的思想更加清晰，更加有条理。 我将在博客中记录包括但不限于如下内容： 学习笔记 网络安全相关知识 上课过程中的思考 开发过程中的问题 生活内容 旅游 工作 在这个 blog 当中，我希望能将困难的知识讲解清楚，希望能让作为读者的你有所收获，希望能引起你的思考，引起你的共鸣。如果你有任何的问题，你可以发邮件与我交流，我的邮箱是：superstarhackboy[at]gmail.com。","link":"/2023/07/30/hello-world/"},{"title":"【.NET 安全】 01-环境搭建&amp;反序列化入门","text":"前言这个星期稍微学习了一下.NET反序列化相关的知识，所以想写一篇文章系统的梳理一下.NET安全的相关知识。在阅读了市面上的.NET反序列化文章后，对比Java反序列化，虽然.NET在Web开发中已经用的非常多了，但是针对其安全研究较少，只有部分师傅做过.NET分析。市面上的文章质量一言难尽，鲜有文章能讲明白，讲清楚。 环境搭建最常见的C#开发写工具是Visual Studio，作为微软爸爸的官方标配，其各种功能都很完善。但是对于安全研究人员（起码是对于我来说），用起来不太顺手，并且很多功能可能不太需要。 这里我推荐使用JetBrians家的Rider作为主力的开发工具和调试工具。对于我来说，Rider有这么几个点吸引我 统一的快捷键和UI，对于熟悉IDEA等JB家族IDE的师傅来说，VS的快捷键和JB的快捷键差别太大，用起来手感很差。 自带C#反编译和调试功能，很多师傅还在用dySpy来对没有代码的C#dll文件进行调试，但是Rider和IDEA类似，继承了反编译工具和调试功能，用起来不要说太爽。下图就是SessionSecurityToken的反编译的结果，效果非常好！ 软件体积小，相较于VS动辄几十个G的安装大小，Rider的体积就小很多了。 这里非常推荐初学者用Rider进行C#代码的编写和调试，手感棒棒的！至于如何安装Rider，这个我相信绝大多数师傅应该都没问题，这里就不在多说。 一个常见的小问题在写代码的时候会经常发现有一些类找不到，这个时候我们需要右键Dependencies并点击Reference。 之后，搜索你需要的依赖库，并Add就可以了。如果你的依赖库是一个dll文件，你可以点击下面的Add From并选择对应文件也可以添加。 一些与反序列化无关的知识点在.NET中执行命令在Java的CC链反序列化中，我们可以通过Runtime.getRuntime().exec()执行命令。同样的，在.NET中我们可以使用Process.Start()去执行命令[1]，值得高兴的是Process.Start是一个static方法，可以直接调用，不需要像在Java中调用getRuntime()获取Instance。 Process.Start有多个定义，其中最简单的就是上图中的。其有两个参数，第一个参数为fileName一般为cmd.exe，第二个参数是arguments，通常为/c &lt;command&gt;。代码写起来也很简单 12345678910111213141516using System.Diagnostics;namespace Lesson01{ internal class Program { private static void RunCommand(string cmd) { Process.Start(&quot;cmd.exe&quot;, &quot;/c &quot; + cmd); } public static void Main(string[] args) { RunCommand(&quot;calc.exe&quot;); } }} 在.NET中加载dll这里的dll不是指那些用C/C++语言编写的动态链接库，而是.NET的依赖库，可以理解为Java中的class文件。类似于Java中调用TemplatesImpl加载class文件，在.NET可以用Assembly.Load直接加载dll文件。 ExploitClass我们首先需要编写一个dll项目。在Rider中，我们右键解决方案名称，选择New Project，选择Class Library，最后点击Create 在生成的代码中，添加构造函数，这样我们的库就写完了。 123456789101112using System.Diagnostics;namespace ExploitClass{ public class ExploitClass { public ExploitClass() { Process.Start(&quot;cmd.exe&quot;, &quot;/c calc.exe&quot;); } }} Loader在Loader中，我们需要使用Assembly.Load加载我们上面编写的dll文件。我们可能需要在Loader Project中添加ExploitClass的引用。 这样之后我们可以直接用下面的代码获得ExploitClass的dll地址了。 1typeof(ExploitClass.ExploitClass).Assembly.Location Assembly.Load的用法也很简单，第一个参数是dll的字节码即可。 1234var dllLocation = typeof(ExploitClass.ExploitClass).Assembly.Location;Console.WriteLine(&quot;Dll Location: &quot; + dllLocation);var dll = File.ReadAllBytes(dllLocation);Assembly.Load(dll).CreateInstance(&quot;ExploitClass.ExploitClass&quot;); 可以看到这种方法有一定的局限性，需要访问到这个ExploitClass（这里用了CreateInstance），才可以执行。为了解决这个问题，可以使用ModuleInit.Fody这个库设置C# module的init函数 12345678910namespace ExploitClass{ public static class ModuleInitializer { public static void Initialize() { System.Diagnostics.Process.Start(&quot;cmd.exe&quot;, &quot;/c calc&quot;); } }} 这样的话就不需要CreateInstance了，在Assembly.Load的时候就可以执行命令了。 .NET中的反序列化器在笔者的学习过程中，见识了了很多反序列化器： 有以Serializer结尾的XmlSerializer[2],DataContractSerializer[3],JavaScriptSerializer 等； 有以Formatter结尾的BinaryFormatter,SoapFormatter等； 有以Reader等结尾的XamlReader等； 甚至第三方的如JSON.NET， 这些反序列化器各不相同。在此我们分类进行介绍。 Formatter序列化以Formatter反序列化器作为入门篇可能是对初学者最方便的了，Formatter反序列化器是一个C#支持的，非常标准的反序列化器。常见的Formatter序列化器有下面几种： BinaryFormatter：生成的序列化数据是二进制 SoapFormatter：生成的数据用于Soap请求 ObjectStateFormatter：用于生成ViewState这种状态 12345678910using (MemoryStream memoryStream = new MemoryStream()){ // 序列化 var formatter = new BinaryFormatter(); // 可以替换为其他formatter formatter.Serialize(memoryStream, myObject); memoryStream.Position = 0; // 反序列化 var myObject = formatter.Deserialize(memoryStream);} 上面的代码展示了针对一个Object对象进行序列化和反序列化的过程。 用于控制序列化过程的注解但是不是所有的类都可以被Formatter序列化器进行序列化，下面是一个标准的，可以使用Formatter序列器进行序列化的对象 12345678910111213141516171819202122232425[Serializable]public class CustomObject1{ [OnDeserializing] private void TestOnDeserializing(StreamingContext sc) { Console.WriteLine(&quot;TestOnDeserializing&quot;); } [OnDeserialized] private void TestOnDeserialized(StreamingContext sc) { Console.WriteLine(&quot;TestOnDeserialized&quot;); } [OnSerializing] private void TestOnSerializing(StreamingContext sc) { Console.WriteLine(&quot;TestOnSerializing&quot;); } [OnSerialized] private void TestOnSerialized(StreamingContext sc) { Console.WriteLine(&quot;TestOnSerialized&quot;); } } 所有支持Formatter序列化的对象都需要在类的声明位置标注[Serializable]。在类当中可以指定[OnDeserializing],[OnDeserialized],[OnSerializing],[OnSerialized]4种注解，来指定序列化和反序列化中的行为。当然，除了Formatter类之外，有一些其他的序列化器可以使用上述注解。 我们用这个代码对CustomObject1进行序列化测试，可以观察到如下输出： 这说明在默认情况下，序列化的会先执行[OnSerializing]标注的函数，在最后会执行[OnSerialized]。反序列化的时候同理：会先执行[OnDeserializing]标注的函数，在最后会执行[OnDeserialized]。如果某个标注了[OnDeserializing]/[OnDeserialized]函数在执行反序列化存在可以RCE的地方，那么就可以在反序列化的时候实现RCE。 ISerializable接口除了上述的注解之外，如果对象实现了ISerializable也可以通过构造函数和GetObjectData函数控制序列化过程。下面展示了一个带有对应函数的类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344[Serializable]public class CustomObject2: ISerializable{ [NonSerialized] private string _val; public CustomObject2() { } protected CustomObject2(SerializationInfo info, StreamingContext context) { Console.WriteLine(&quot;CustomObject2 constructor is called&quot;); _val = info.GetString(&quot;foooo&quot;); } public void GetObjectData(SerializationInfo info, StreamingContext context) { Console.WriteLine(&quot;GetObjectData&quot;); info.AddValue(&quot;foooo&quot;, _val); } [OnDeserializing] private void TestOnDeserializing(StreamingContext sc) { Console.WriteLine(&quot;TestOnDeserializing&quot;); } [OnDeserialized] private void TestOnDeserialized(StreamingContext sc) { Console.WriteLine(&quot;TestOnDeserialized&quot;); } [OnSerializing] private void TestOnSerializing(StreamingContext sc) { Console.WriteLine(&quot;TestOnSerializing&quot;); } [OnSerialized] private void TestOnSerialized(StreamingContext sc) { Console.WriteLine(&quot;TestOnSerialized&quot;); } } 同样，我们对这个类进行序列化和反序列化，可以看到其调用顺序 OK，到此为止我们可以总结出一个流程 SurrogateSelector在序列化的时候，我们可以通过设置fomatter的SurrogateSelector来指定序列化代理选择器。通过SurrogateSelector，可以自定义GetObjectData和SetObjectData从而控制序列化和反序列化流程。 通过设置代理器，可以将Formatter不支持序列化的对象进行序列化从而达到扩展Formatter的效果。 参考Y4er师傅的dotnet-serialize-101[4],下面是一个没有标注序列化的类，在默认情况下是不能序列化的。 12345678910111213class Person{ public string Name { get; set; } public Person(string name) { Name = name; } public override string ToString() { return Name; }} 如果我们想序列化这个类，那就需要使用代理器了。下面是一个针对Person对象的序列化代理器，其设置了序列化该类的方法GetObjectData，和反序列化该类的方法SetObjectData。 12345678910111213141516class PersonSerializeSurrogate : ISerializationSurrogate{ public void GetObjectData(Object obj, SerializationInfo info, StreamingContext context) { var p = (Person)obj; info.AddValue(&quot;Name&quot;, p.Name); } public Object SetObjectData(Object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector) { var p = (Person)obj; p.Name = info.GetString(&quot;Name&quot;); return p; }} 我们通过设置代理，就可以序列化了 12345var formatter = new BinaryFormatter(); // 可以替换为其他formatterSurrogateSelector ss = new SurrogateSelector(); // 创建selectorss.AddSurrogate(typeof(Person), formatter.Context, new PersonSerializeSurrogate()); // 为Person对象设置代理器formatter.SurrogateSelector = ss; // 设置代理选择器formatter.Serialize(memoryStream, new Person(&quot;name&quot;)); 在设置完对象之后，序列化和反序列化的过程就有些不一样了，下面是Y4er师傅总结的流程。 Serializer序列化Serializer家族相对于Formatter家族就复杂一些，比如说最常见的XmlSerializer就不受上面注解的影响。 XmlSerializerXmlSerializer进行序列化和反序列化的时候需要指定对应的ClassType，下面是XmlSerializer序列化和反序列化的标准代码: 1234567891011XmlSerializer xmlSerializer = new XmlSerializer(typeof(XmlObject2));using (MemoryStream memoryStream = new MemoryStream()){ var obj = new XmlObject2(); TextWriter writer = new StreamWriter(memoryStream); xmlSerializer.Serialize(writer, obj); memoryStream.Position = 0; Console.WriteLine(Encoding.UTF8.GetString(memoryStream.ToArray())); XmlObject2 p1 = (XmlObject2)xmlSerializer.Deserialize(memoryStream);} 我们可以看到在new XmlSerializer()的时候，构造函数的第一个参数代表所序列化类的类型，这在一定程度上限制了XmlSerializer的利用场景。在研究XmlSerializer的序列化和反序列化的时候， 使用 XmlInclude或SoapInclude 特性静态指定非已知的类型我经常遇到一个报错：使用 XmlInclude或SoapInclude 特性静态指定非已知的类型，Y4er也在文章中提到了这个报错，不过他的解释我没怎么看懂，我这里在来详细说明一下。我们设想下面这个类： 1234567891011public class XmlObject{ public string Name; public string Value;}public class XmlObject2{ public object AnyObj;} 当我们序列化下面这个对象的时候 123var obj = new XmlObject2();obj.AnyObj = new XmlObject2();xmlSerializer.Serialize(writer, obj); 你会发现序列化的结果很正常： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;XmlObject2 xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt; &lt;AnyObj xsi:type=&quot;XmlObject2&quot; /&gt;&lt;/XmlObject2&gt; 但是，如果你讲AnyObj的值设置为new XmlObject()，也就是： 123var obj = new XmlObject2();obj.AnyObj = new XmlObject();xmlSerializer.Serialize(writer, obj); 你会惊奇的发现，上面的代码报错了。 我猜测：在创建序列化器的时候，需要指定一个类型，那么在序列化的过程中，序列化器会遍历对象所有的元素，如果某个元素超出了在创建序列化器指定的类型（比如说这里的XmlObject），那么就会抛出这个报错。 那么解决这个问题的方式有2种： 在创建的时候把你需要的类加进去。 利用XmlInclude将你需要的类加进去。 第二种可以参考官方文档，这里不在赘述（未来也用不上）。第一种的实现方案看似很难，其实只需要利用好泛型。在.NET的反序列化中常见的可以有很多泛型的类是ExpandedWrapper。 123var obj = new ExpandedWrapper&lt;XmlObject, XmlObject2&gt;();obj.ProjectedProperty0 = new XmlObject2();obj.ProjectedProperty0.AnyObj = new XmlObject(); 我们将之前的代码改成这样，就可以成功序列化了。 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;ExpandedWrapperOfXmlObjectXmlObject2 xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt; &lt;ProjectedProperty0&gt; &lt;AnyObj xsi:type=&quot;XmlObject&quot; /&gt; &lt;/ProjectedProperty0&gt;&lt;/ExpandedWrapperOfXmlObjectXmlObject2&gt; DataContractSerializer &amp; DataContractJsonSerializer这两个差别不大，合在一起说了。前一个出来的结果是XML类型，后一个是JSON类型。虽然DataContractSerializer和XmlSerializer都是Serializer和XML输出，但是两者可以说完全不同。下面是DataContractSerializer的标准序列化和反序列化代码： 1234567891011var s = new DataContractSerializer(typeof(DemoObject2));using (MemoryStream memoryStream = new MemoryStream()){ var obj = new DemoObject2(); obj.AnyObj = new DemoObject2(); s.WriteObject(memoryStream, obj); memoryStream.Position = 0; Console.WriteLine(Encoding.UTF8.GetString(memoryStream.ToArray())); var p1 = s.ReadObject(memoryStream);} 这居然用WriteObject和ReadObject，咋和Java一样呢？ 【待续。。。】 参考文献1.https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.start?view=net-7.0 ↩2.https://learn.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer?view=net-7.0 ↩3.https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.datacontractserializer?view=net-7.0 ↩4.https://github.com/Y4er/dotnet-deserialization/blob/main/dotnet-serialize-101.md ↩","link":"/2023/08/05/dotNetSecurity-01/"}],"tags":[{"name":".NET安全","slug":"NET安全","link":"/tags/NET%E5%AE%89%E5%85%A8/"},{"name":"反序列化","slug":"反序列化","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Startup","slug":"Startup","link":"/tags/Startup/"}],"categories":[{"name":"Startup","slug":"Startup","link":"/categories/Startup/"}],"pages":[{"title":"About myself","text":"Introduction北邮硕士在读，天枢战队队长，主要研究方向为：Web 安全，安全开发，渗透测试，Android 安全。 Competition在北京邮电大学所获的奖项如下： 2023 年全国大学生信息安全竞赛 冠军 Internship 2019 年 字节跳动无恒实验室 2021 年 腾讯科恩安全实验室 2023 年 DarkNavy 安全实验室","link":"/about/index.html"}]}