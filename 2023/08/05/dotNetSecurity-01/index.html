<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>【.NET 安全】 01-环境搭建&amp;反序列化入门 - Sndav Daily Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Sndav Blog"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Sndav Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前言这个星期稍微学习了一下.NET反序列化相关的知识，所以想写一篇文章系统的梳理一下.NET安全的相关知识。在阅读了市面上的.NET反序列化文章后，对比Java反序列化，虽然.NET在Web开发中已经用的非常多了，但是针对其安全研究较少，只有部分师傅做过.NET分析。市面上的文章质量一言难尽，鲜有文章能讲明白，讲清楚。"><meta property="og:type" content="blog"><meta property="og:title" content="【.NET 安全】 01-环境搭建&amp;反序列化入门"><meta property="og:url" content="https://blog.naive.codes/2023/08/05/dotNetSecurity-01/"><meta property="og:site_name" content="Sndav Daily Blog"><meta property="og:description" content="前言这个星期稍微学习了一下.NET反序列化相关的知识，所以想写一篇文章系统的梳理一下.NET安全的相关知识。在阅读了市面上的.NET反序列化文章后，对比Java反序列化，虽然.NET在Web开发中已经用的非常多了，但是针对其安全研究较少，只有部分师傅做过.NET分析。市面上的文章质量一言难尽，鲜有文章能讲明白，讲清楚。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805161020768.png"><meta property="og:image" content="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805161732169.png"><meta property="og:image" content="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805161831336.png"><meta property="og:image" content="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805194743751.png"><meta property="og:image" content="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805200026867.png"><meta property="og:image" content="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805200346348.png"><meta property="og:image" content="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805200920975.png"><meta property="og:image" content="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805235653200.png"><meta property="og:image" content="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230806105348925.png"><meta property="og:image" content="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230806110724450.png"><meta property="og:image" content="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230806113607424.png"><meta property="og:image" content="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230806152953162.png"><meta property="article:published_time" content="2023-08-05T06:38:45.000Z"><meta property="article:modified_time" content="2023-08-06T09:04:18.470Z"><meta property="article:author" content="Sndav"><meta property="article:tag" content=".NET安全"><meta property="article:tag" content="反序列化"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805161020768.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.naive.codes/2023/08/05/dotNetSecurity-01/"},"headline":"【.NET 安全】 01-环境搭建&反序列化入门","image":["https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805161020768.png","https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805161732169.png","https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805161831336.png","https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805194743751.png","https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805200026867.png","https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805200346348.png","https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805200920975.png","https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805235653200.png","https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230806105348925.png","https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230806110724450.png","https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230806113607424.png","https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230806152953162.png"],"datePublished":"2023-08-05T06:38:45.000Z","dateModified":"2023-08-06T09:04:18.470Z","author":{"@type":"Person","name":"Sndav"},"publisher":{"@type":"Organization","name":"Sndav Daily Blog","logo":{"@type":"ImageObject"}},"description":"前言这个星期稍微学习了一下.NET反序列化相关的知识，所以想写一篇文章系统的梳理一下.NET安全的相关知识。在阅读了市面上的.NET反序列化文章后，对比Java反序列化，虽然.NET在Web开发中已经用的非常多了，但是针对其安全研究较少，只有部分师傅做过.NET分析。市面上的文章质量一言难尽，鲜有文章能讲明白，讲清楚。"}</script><link rel="canonical" href="https://blog.naive.codes/2023/08/05/dotNetSecurity-01/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?c61a407a60436d923d5ae1c816c47813";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Sndav Daily Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-05T06:38:45.000Z" title="8/5/2023, 2:38:45 PM">2023-08-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-08-06T09:04:18.470Z" title="8/6/2023, 5:04:18 PM">2023-08-06</time></span><span class="level-item">22 minutes read (About 3268 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">【.NET 安全】 01-环境搭建&amp;反序列化入门</h1><div class="content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个星期稍微学习了一下<code>.NET</code>反序列化相关的知识，所以想写一篇文章系统的梳理一下<code>.NET</code>安全的相关知识。在阅读了市面上的<code>.NET</code>反序列化文章后，对比Java反序列化，虽然<code>.NET</code>在Web开发中已经用的非常多了，但是针对其安全研究较少，只有部分师傅做过<code>.NET</code>分析。市面上的文章质量一言难尽，鲜有文章能讲明白，讲清楚。</p>
<span id="more"></span>

<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>最常见的<code>C#</code>开发写工具是<code>Visual Studio</code>，作为微软爸爸的官方标配，其各种功能都很完善。但是对于安全研究人员（起码是对于我来说），用起来不太顺手，并且很多功能可能不太需要。</p>
<p>这里我推荐使用<code>JetBrians</code>家的<code>Rider</code>作为主力的开发工具和调试工具。对于我来说，Rider有这么几个点吸引我</p>
<ul>
<li><p>统一的快捷键和UI，对于熟悉IDEA等JB家族IDE的师傅来说，VS的快捷键和JB的快捷键差别太大，用起来手感很差。</p>
</li>
<li><p>自带<code>C#</code>反编译和调试功能，很多师傅还在用dySpy来对没有代码的<code>C#</code>dll文件进行调试，但是Rider和IDEA类似，继承了反编译工具和调试功能，用起来不要说太爽。下图就是SessionSecurityToken的反编译的结果，效果非常好！</p>
<p><img src="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805161020768.png" alt="image-20230805161020768"></p>
</li>
<li><p>软件体积小，相较于VS动辄几十个G的安装大小，Rider的体积就小很多了。</p>
</li>
</ul>
<p>这里非常推荐初学者用Rider进行C#代码的编写和调试，手感棒棒的！至于如何安装Rider，这个我相信绝大多数师傅应该都没问题，这里就不在多说。</p>
<h3 id="一个常见的小问题"><a href="#一个常见的小问题" class="headerlink" title="一个常见的小问题"></a>一个常见的小问题</h3><p>在写代码的时候会经常发现有一些类找不到，这个时候我们需要右键Dependencies并点击Reference。</p>
<center><img src="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805161732169.png" alt="image-20230805161732169" style="zoom: 50%;" /></center>

<p>之后，搜索你需要的依赖库，并Add就可以了。如果你的依赖库是一个dll文件，你可以点击下面的Add From并选择对应文件也可以添加。</p>
<center><img src="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805161831336.png" alt="Add Reference" style="zoom: 50%;" /></center>



<h2 id="一些与反序列化无关的知识点"><a href="#一些与反序列化无关的知识点" class="headerlink" title="一些与反序列化无关的知识点"></a>一些与反序列化无关的知识点</h2><h3 id="在-NET中执行命令"><a href="#在-NET中执行命令" class="headerlink" title="在.NET中执行命令"></a>在.NET中执行命令</h3><p>在Java的CC链反序列化中，我们可以通过<code>Runtime.getRuntime().exec()</code>执行命令。同样的，在<code>.NET</code>中我们可以使用<code>Process.Start()</code>去执行命令<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.start?view=net-7.0
">[1]</span></a></sup>，值得高兴的是<code>Process.Start</code>是一个static方法，可以直接调用，不需要像在Java中调用<code>getRuntime()</code>获取Instance。</p>
<p><img src="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805194743751.png" alt="Process.Start"></p>
<p><code>Process.Start</code>有多个定义，其中最简单的就是上图中的。其有两个参数，第一个参数为<code>fileName</code>一般为<code>cmd.exe</code>，第二个参数是<code>arguments</code>，通常为<code>/c &lt;command&gt;</code>。代码写起来也很简单</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Lesson01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RunCommand</span>(<span class="params"><span class="built_in">string</span> cmd</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Process.Start(<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c &quot;</span> + cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            RunCommand(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805200026867.png" alt="RunCommand"></p>
<h3 id="在-NET中加载dll"><a href="#在-NET中加载dll" class="headerlink" title="在.NET中加载dll"></a>在.NET中加载dll</h3><p>这里的dll不是指那些用C&#x2F;C++语言编写的动态链接库，而是<code>.NET</code>的依赖库，可以理解为Java中的class文件。类似于Java中调用TemplatesImpl加载class文件，在<code>.NET</code>可以用<code>Assembly.Load</code>直接加载dll文件。</p>
<h4 id="ExploitClass"><a href="#ExploitClass" class="headerlink" title="ExploitClass"></a>ExploitClass</h4><p>我们首先需要编写一个dll项目。在Rider中，我们右键解决方案名称，选择New Project，选择Class Library，最后点击Create</p>
<p><img src="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805200346348.png" alt="创建dll项目"></p>
<p>在生成的代码中，添加构造函数，这样我们的库就写完了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ExploitClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExploitClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExploitClass</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Process.Start(<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c calc.exe&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h4><p>在Loader中，我们需要使用<code>Assembly.Load</code>加载我们上面编写的dll文件。我们可能需要在Loader Project中添加ExploitClass的引用。</p>
<center><img src="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805200920975.png" alt="添加ExploitClass的引用" style="zoom:50%;" /></center>

<p>这样之后我们可以直接用下面的代码获得ExploitClass的dll地址了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(ExploitClass.ExploitClass).Assembly.Location</span><br></pre></td></tr></table></figure>

<p><code>Assembly.Load</code>的用法也很简单，第一个参数是dll的字节码即可。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dllLocation = <span class="keyword">typeof</span>(ExploitClass.ExploitClass).Assembly.Location;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Dll Location: &quot;</span> + dllLocation);</span><br><span class="line"><span class="keyword">var</span> dll = File.ReadAllBytes(dllLocation);</span><br><span class="line">Assembly.Load(dll).CreateInstance(<span class="string">&quot;ExploitClass.ExploitClass&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到这种方法有一定的局限性，需要访问到这个<code>ExploitClass</code>（这里用了<code>CreateInstance</code>），才可以执行。为了解决这个问题，可以使用<code>ModuleInit.Fody</code>这个库设置C# module的init函数</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ExploitClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ModuleInitializer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Initialize</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.Diagnostics.Process.Start(<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c calc&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话就不需要<code>CreateInstance</code>了，在<code>Assembly.Load</code>的时候就可以执行命令了。</p>
<h2 id="NET中的反序列化器"><a href="#NET中的反序列化器" class="headerlink" title=".NET中的反序列化器"></a>.NET中的反序列化器</h2><p>在笔者的学习过程中，见识了了很多反序列化器：</p>
<ul>
<li>有以<code>Serializer</code>结尾的<code>XmlSerializer</code><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://learn.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer?view=net-7.0
">[2]</span></a></sup>,<code>DataContractSerializer</code><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.datacontractserializer?view=net-7.0
">[3]</span></a></sup>,<code>JavaScriptSerializer</code> 等；</li>
<li>有以<code>Formatter</code>结尾的<code>BinaryFormatter</code>,<code>SoapFormatter</code>等；</li>
<li>有以<code>Reader</code>等结尾的<code>XamlReader</code>等；</li>
<li>甚至第三方的如<code>JSON.NET</code>，</li>
</ul>
<p>这些反序列化器各不相同。在此我们分类进行介绍。</p>
<h3 id="Formatter序列化"><a href="#Formatter序列化" class="headerlink" title="Formatter序列化"></a>Formatter序列化</h3><p>以Formatter反序列化器作为入门篇可能是对初学者最方便的了，Formatter反序列化器是一个<code>C#</code>支持的，非常标准的反序列化器。常见的Formatter序列化器有下面几种：</p>
<ul>
<li>BinaryFormatter：生成的序列化数据是二进制</li>
<li>SoapFormatter：生成的数据用于Soap请求</li>
<li>ObjectStateFormatter：用于生成ViewState这种状态</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (MemoryStream memoryStream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="keyword">var</span> formatter = <span class="keyword">new</span> BinaryFormatter(); <span class="comment">// 可以替换为其他formatter</span></span><br><span class="line">	formatter.Serialize(memoryStream, myObject);</span><br><span class="line">    memoryStream.Position = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="keyword">var</span> myObject = formatter.Deserialize(memoryStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码展示了针对一个Object对象进行序列化和反序列化的过程。</p>
<h4 id="用于控制序列化过程的注解"><a href="#用于控制序列化过程的注解" class="headerlink" title="用于控制序列化过程的注解"></a>用于控制序列化过程的注解</h4><p>但是不是所有的类都可以被Formatter序列化器进行序列化，下面是一个标准的，可以使用Formatter序列器进行序列化的对象</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomObject1</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">OnDeserializing</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnDeserializing</span>(<span class="params">StreamingContext sc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnDeserializing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">OnDeserialized</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnDeserialized</span>(<span class="params">StreamingContext sc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnDeserialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">OnSerializing</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnSerializing</span>(<span class="params">StreamingContext sc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnSerializing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">OnSerialized</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnSerialized</span>(<span class="params">StreamingContext sc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnSerialized&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所有</strong>支持Formatter序列化的对象都需要在类的声明位置标注<code>[Serializable]</code>。在类当中可以指定<code>[OnDeserializing]</code>,<code>[OnDeserialized]</code>,<code>[OnSerializing]</code>,<code>[OnSerialized]</code>4种注解，来指定序列化和反序列化中的行为。当然，除了Formatter类之外，有一些其他的序列化器可以使用上述注解。</p>
<p>我们用这个代码对<code>CustomObject1</code>进行序列化测试，可以观察到如下输出：</p>
<p><img src="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230805235653200.png" alt="image-20230805235653200"></p>
<p>这说明在默认情况下，序列化的会先执行<code>[OnSerializing]</code>标注的函数，在最后会执行<code>[OnSerialized]</code>。反序列化的时候同理：会先执行<code>[OnDeserializing]</code>标注的函数，在最后会执行<code>[OnDeserialized]</code>。如果某个标注了<code>[OnDeserializing]/[OnDeserialized]</code>函数在执行反序列化存在可以RCE的地方，那么就可以在反序列化的时候实现RCE。</p>
<h4 id="ISerializable接口"><a href="#ISerializable接口" class="headerlink" title="ISerializable接口"></a>ISerializable接口</h4><p>除了上述的注解之外，如果对象实现了<code>ISerializable</code>也可以通过构造函数和<code>GetObjectData</code>函数控制序列化过程。下面展示了一个带有对应函数的类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomObject2</span>: <span class="title">ISerializable</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">NonSerialized</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomObject2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CustomObject2</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;CustomObject2 constructor is called&quot;</span>);</span><br><span class="line">        _val = info.GetString(<span class="string">&quot;foooo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;GetObjectData&quot;</span>);</span><br><span class="line">        info.AddValue(<span class="string">&quot;foooo&quot;</span>, _val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">OnDeserializing</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnDeserializing</span>(<span class="params">StreamingContext sc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnDeserializing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">OnDeserialized</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnDeserialized</span>(<span class="params">StreamingContext sc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnDeserialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">OnSerializing</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnSerializing</span>(<span class="params">StreamingContext sc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnSerializing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">OnSerialized</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOnSerialized</span>(<span class="params">StreamingContext sc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;TestOnSerialized&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，我们对这个类进行序列化和反序列化，可以看到其调用顺序</p>
<p><img src="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230806105348925.png" alt="image-20230806105348925"></p>
<p>OK，到此为止我们可以总结出一个流程</p>
<center><img src="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230806110724450.png" alt="image-20230806110724450" style="zoom:50%;" /></center>

<h4 id="SurrogateSelector"><a href="#SurrogateSelector" class="headerlink" title="SurrogateSelector"></a>SurrogateSelector</h4><p>在序列化的时候，我们可以通过设置fomatter的SurrogateSelector来指定序列化代理选择器。通过SurrogateSelector，可以自定义GetObjectData和SetObjectData从而控制序列化和反序列化流程。</p>
<blockquote>
<p>通过设置代理器，可以将Formatter不支持序列化的对象进行序列化从而达到扩展Formatter的效果。</p>
</blockquote>
<p>参考Y4er师傅的dotnet-serialize-101<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://github.com/Y4er/dotnet-deserialization/blob/main/dotnet-serialize-101.md">[4]</span></a></sup>,下面是一个没有标注序列化的类，在默认情况下是不能序列化的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想序列化这个类，那就需要使用代理器了。下面是一个针对Person对象的序列化代理器，其设置了序列化该类的方法<code>GetObjectData</code>，和反序列化该类的方法<code>SetObjectData</code>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">PersonSerializeSurrogate</span> : <span class="title">ISerializationSurrogate</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">Object obj, SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> p = (Person)obj;</span><br><span class="line">        info.AddValue(<span class="string">&quot;Name&quot;</span>, p.Name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">SetObjectData</span>(<span class="params">Object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> p = (Person)obj;</span><br><span class="line">        p.Name = info.GetString(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过设置代理，就可以序列化了</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formatter = <span class="keyword">new</span> BinaryFormatter(); <span class="comment">// 可以替换为其他formatter</span></span><br><span class="line">SurrogateSelector ss = <span class="keyword">new</span> SurrogateSelector(); <span class="comment">// 创建selector</span></span><br><span class="line">ss.AddSurrogate(<span class="keyword">typeof</span>(Person), formatter.Context, <span class="keyword">new</span> PersonSerializeSurrogate()); <span class="comment">// 为Person对象设置代理器</span></span><br><span class="line">formatter.SurrogateSelector = ss; <span class="comment">// 设置代理选择器</span></span><br><span class="line">formatter.Serialize(memoryStream, <span class="keyword">new</span> Person(<span class="string">&quot;name&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>在设置完对象之后，序列化和反序列化的过程就有些不一样了，下面是Y4er师傅总结的流程。</p>
<p><img src="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230806113607424.png" alt="image-20230806113607424"></p>
<h3 id="Serializer序列化"><a href="#Serializer序列化" class="headerlink" title="Serializer序列化"></a>Serializer序列化</h3><p><code>Serializer</code>家族相对于<code>Formatter</code>家族就复杂一些，比如说最常见的<code>XmlSerializer</code>就不受上面注解的影响。</p>
<h4 id="XmlSerializer"><a href="#XmlSerializer" class="headerlink" title="XmlSerializer"></a>XmlSerializer</h4><p>XmlSerializer进行序列化和反序列化的时候需要指定对应的ClassType，下面是XmlSerializer序列化和反序列化的标准代码:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">XmlSerializer xmlSerializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(XmlObject2));</span><br><span class="line"><span class="keyword">using</span> (MemoryStream memoryStream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> XmlObject2();</span><br><span class="line">    TextWriter writer = <span class="keyword">new</span> StreamWriter(memoryStream);</span><br><span class="line">    xmlSerializer.Serialize(writer, obj);</span><br><span class="line">    memoryStream.Position = <span class="number">0</span>;</span><br><span class="line">    Console.WriteLine(Encoding.UTF8.GetString(memoryStream.ToArray()));</span><br><span class="line"></span><br><span class="line">    XmlObject2 p1 = (XmlObject2)xmlSerializer.Deserialize(memoryStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到在<code>new XmlSerializer()</code>的时候，构造函数的第一个参数代表所序列化类的类型，这在一定程度上限制了XmlSerializer的利用场景。在研究XmlSerializer的序列化和反序列化的时候，</p>
<h5 id="使用-XmlInclude或SoapInclude-特性静态指定非已知的类型"><a href="#使用-XmlInclude或SoapInclude-特性静态指定非已知的类型" class="headerlink" title="使用 XmlInclude或SoapInclude 特性静态指定非已知的类型"></a>使用 XmlInclude或SoapInclude 特性静态指定非已知的类型</h5><p>我经常遇到一个报错：<code>使用 XmlInclude或SoapInclude 特性静态指定非已知的类型</code>，Y4er也在文章中提到了这个报错，不过他的解释我没怎么看懂，我这里在来详细说明一下。我们设想下面这个类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">XmlObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">XmlObject2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> AnyObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们序列化下面这个对象的时候</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> XmlObject2();</span><br><span class="line">obj.AnyObj = <span class="keyword">new</span> XmlObject2();</span><br><span class="line">xmlSerializer.Serialize(writer, obj);</span><br></pre></td></tr></table></figure>

<p>你会发现序列化的结果很正常：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">XmlObject2</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">AnyObj</span> <span class="attr">xsi:type</span>=<span class="string">&quot;XmlObject2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">XmlObject2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是，如果你讲AnyObj的值设置为<code>new XmlObject()</code>，也就是：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> XmlObject2();</span><br><span class="line">obj.AnyObj = <span class="keyword">new</span> XmlObject();</span><br><span class="line">xmlSerializer.Serialize(writer, obj);</span><br></pre></td></tr></table></figure>

<p>你会惊奇的发现，上面的代码报错了。</p>
<p><img src="https://img-1251565221.cos.ap-nanjing.myqcloud.com/img/image-20230806152953162.png" alt="image-20230806152953162"></p>
<p>我猜测：在创建序列化器的时候，需要指定一个类型，那么在序列化的过程中，序列化器会遍历对象所有的元素，如果某个元素超出了在创建序列化器指定的类型（比如说这里的<code>XmlObject</code>），那么就会抛出这个报错。</p>
<p>那么解决这个问题的方式有2种：</p>
<ol>
<li>在创建的时候把你需要的类加进去。</li>
<li>利用<code>XmlInclude</code>将你需要的类加进去。</li>
</ol>
<p>第二种可以参考官方文档，这里不在赘述（未来也用不上）。第一种的实现方案看似很难，其实只需要利用好泛型。在<code>.NET</code>的反序列化中常见的可以有很多泛型的类是<code>ExpandedWrapper</code>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> ExpandedWrapper&lt;XmlObject, XmlObject2&gt;();</span><br><span class="line">obj.ProjectedProperty0 = <span class="keyword">new</span> XmlObject2();</span><br><span class="line">obj.ProjectedProperty0.AnyObj = <span class="keyword">new</span> XmlObject();</span><br></pre></td></tr></table></figure>

<p>我们将之前的代码改成这样，就可以成功序列化了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ExpandedWrapperOfXmlObjectXmlObject2</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ProjectedProperty0</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AnyObj</span> <span class="attr">xsi:type</span>=<span class="string">&quot;XmlObject&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ProjectedProperty0</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ExpandedWrapperOfXmlObjectXmlObject2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="DataContractSerializer-DataContractJsonSerializer"><a href="#DataContractSerializer-DataContractJsonSerializer" class="headerlink" title="DataContractSerializer &amp; DataContractJsonSerializer"></a>DataContractSerializer &amp; DataContractJsonSerializer</h4><p>这两个差别不大，合在一起说了。前一个出来的结果是XML类型，后一个是JSON类型。虽然<code>DataContractSerializer</code>和<code>XmlSerializer</code>都是<code>Serializer</code>和<code>XML</code>输出，但是两者可以说完全不同。下面是<code>DataContractSerializer</code>的标准序列化和反序列化代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> DataContractSerializer(<span class="keyword">typeof</span>(DemoObject2));</span><br><span class="line"><span class="keyword">using</span> (MemoryStream memoryStream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> DemoObject2();</span><br><span class="line">    obj.AnyObj = <span class="keyword">new</span> DemoObject2();</span><br><span class="line">    s.WriteObject(memoryStream, obj);</span><br><span class="line">    memoryStream.Position = <span class="number">0</span>;</span><br><span class="line">    Console.WriteLine(Encoding.UTF8.GetString(memoryStream.ToArray()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p1 = s.ReadObject(memoryStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这居然用WriteObject和ReadObject，咋和Java一样呢？</p>
</blockquote>
<p>【待续。。。】</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.start?view=net-7.0<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://learn.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer?view=net-7.0<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.datacontractserializer?view=net-7.0<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://github.com/Y4er/dotnet-deserialization/blob/main/dotnet-serialize-101.md<a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/NET%E5%AE%89%E5%85%A8/">.NET安全</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">反序列化</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/07/30/hello-world/"><span class="level-item">Hello World</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://www.gravatar.com/avatar/9395471d2704da2f28ab3c151df5f3d4?s=128" alt="Sndav Bai"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Sndav Bai</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Category</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Sndav" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Sndav"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Startup/"><span class="level-start"><span class="level-item">Startup</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-05T06:38:45.000Z">2023-08-05</time></p><p class="title"><a href="/2023/08/05/dotNetSecurity-01/">【.NET 安全】 01-环境搭建&amp;反序列化入门</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-30T05:16:01.795Z">2023-07-30</time></p><p class="title"><a href="/2023/07/30/hello-world/">Hello World</a></p><p class="categories"><a href="/categories/Startup/">Startup</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/NET%E5%AE%89%E5%85%A8/"><span class="tag">.NET安全</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Startup/"><span class="tag">Startup</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"><span class="tag">反序列化</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Sndav Daily Blog</a><p class="is-size-7"><span>&copy; 2023 Sndav</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/Sndav"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>